HEADER
{
	CompileTargets = ( IS_SM_50 && ( PC || VULKAN ) );
	Description = "Voxel Model";
	DebugInfo = false;
}

FEATURES
{
	#include "common/features.hlsl"

	Feature( F_ALPHA_TEST, 0..1, "Translucent" );
	Feature( F_TRANSLUCENT, 0..1, "Translucent" );
	FeatureRule( Allow1( F_TRANSLUCENT, F_ALPHA_TEST ), "Translucent and Alpha Test are not compatible" );
	Feature( F_PREPASS_ALPHA_TEST, 0..1, "Translucent" );
	Feature( F_NON_DIRECTIONAL_DIFFUSE_LIGHTING, 0..1, "Rendering" );
}

MODES
{
	VrForward();
	Depth( S_MODE_DEPTH );
	ToolsVis( S_MODE_TOOLS_VIS );
	ToolsWireframe( S_MODE_TOOLS_WIREFRAME );
	ToolsShadingComplexity( "vr_tools_shading_complexity.vfx" );
}

COMMON
{
	#include "system.fxc"
	#include "sbox_shared.fxc"
	
	#define VS_INPUT_HAS_TANGENT_BASIS 1
	#define PS_INPUT_HAS_TANGENT_BASIS 1

	StaticCombo( S_ALPHA_TEST, F_ALPHA_TEST, Sys( ALL ) );
	StaticCombo( S_TRANSLUCENT, F_TRANSLUCENT, Sys( ALL ) );
	StaticCombo( S_NON_DIRECTIONAL_DIFFUSE_LIGHTING, F_NON_DIRECTIONAL_DIFFUSE_LIGHTING, Sys( ALL ) );
}

struct VertexInput
{
	#include "common/vertexinput.hlsl"
};

struct PixelInput
{
	#include "common/pixelinput.hlsl"
};

VS
{
	#include "common/vertex.hlsl"
	
	PixelInput MainVs( INSTANCED_SHADER_PARAMS( VS_INPUT i ) )
	{
		PixelInput o = ProcessVertex( i );
		return FinalizeVertex( o );
	}
}

PS
{
	StaticCombo( S_MODE_DEPTH, 0..1, Sys( ALL ) );
	StaticCombo( S_MODE_TOOLS_WIREFRAME, 0..1, Sys( ALL ) );
	StaticCombo( S_DO_NOT_CAST_SHADOWS, F_DO_NOT_CAST_SHADOWS, Sys( ALL ) );

	#if ( S_MODE_TOOLS_WIREFRAME )
		RenderState( FillMode, WIREFRAME );
		RenderState( SlopeScaleDepthBias, -0.5 );
		RenderState( DepthBiasClamp, -0.0005 );
		RenderState( DepthWriteEnable, false );
		#define DEPTH_STATE_ALREADY_SET
	#endif
	
	#include "common/pixel.hlsl"
	
	CreateInputTexture2D( ModelTextureColor, Srgb, 8, "", "_color", "Voxel Pixel,10/10", Default4( 1.0f, 1.0f, 1.0f, 1.0f ) );

	SamplerState g_sPointSampler < Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); >;

	CreateTexture2DWithoutSampler( g_tModelColor )  < Channel( RGBA,  None( ModelTextureColor ), Srgb ); OutputFormat( BC7 ); SrgbRead( true ); Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); >;

	CreateInputTexture2D( ModelTextureNormal,           Linear, 8, "NormalizeNormals", "_normal", 		"Model Material,10/20", Default3( 0.5, 0.5, 1.0 ) );
	CreateInputTexture2D( ModelTextureRoughness,        Linear, 8, "",                 "_rough",  		"Model Material,10/30", Default( 0.5 ) );
	CreateInputTexture2D( ModelTextureMetalness,        Linear, 8, "",                 "_metal",  		"Model Material,10/40", Default( 1.0 ) );
	CreateInputTexture2D( ModelTextureAmbientOcclusion, Linear, 8, "",                 "_ao",     		"Model Material,10/50", Default( 1.0 ) );
	CreateInputTexture2D( ModelTextureEmission, 		Linear, 8, "",                 "_emission",     "Model Material,10/60", Default3( 0.0, 0.0, 0.0 ) );
	CreateInputTexture2D( ModelTextureHue, 				Linear, 8, "",                 "_hue",     		"Model Material,10/70", Default3( 1.0f, 1.0f, 1.0f ) );

	CreateTexture2DWithoutSampler( g_tModelNormal )   < Channel( RGBA, HemiOctNormal( ModelTextureNormal ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
	CreateTexture2DWithoutSampler( g_tModelRma )      < Channel( R,    None( ModelTextureRoughness ), Linear ); Channel( G, None( ModelTextureMetalness ), Linear ); Channel( B, None( ModelTextureAmbientOcclusion ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
	CreateTexture2DWithoutSampler( g_tModelEmission ) < Channel( RGB, None( ModelTextureEmission ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
	CreateTexture2DWithoutSampler( g_tModelHue )  	  < Channel( RGB,  None( ModelTextureHue ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); >;
	
	float4 g_vVoxelLight< Range4(0.0f, 0.0f, 0.0f, 0.0f, 16.0f, 16.0f, 16.0f, 16.0f); Default4(0.0f, 0.0f, 0.0f, 0.0f); >;
	float3 g_vTintColor< Range3(0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f); Default3(1.0f, 1.0f, 1.0f); >;
	int g_HueShift< Range(0, 64); Default(0); >;
	
	BoolAttribute( DoNotCastShadows, F_DO_NOT_CAST_SHADOWS ? true : false );
	
	class ShadingModelValveWithDiffuse : ShadingModel
	{
		CombinerInput Input;
		ShadeParams shadeParams;

		CombinerInput MaterialToCombinerInput( PixelInput i, Material m )
		{
			CombinerInput o;

			o = PS_CommonProcessing( i );
			
			#if ( S_ALPHA_TEST )
			{
				// Clip first to try to kill the wave if we're in an area of all zero
				o.flOpacity = m.Opacity * o.flOpacity;
				clip( o.flOpacity - .001 );

				o.flOpacity = AdjustOpacityForAlphaToCoverage( o.flOpacity, g_flAlphaTestReference, g_flAntiAliasedEdgeStrength, i.vTextureCoords.xy );
				clip( o.flOpacity - 0.001 );
			}
			#elif ( S_TRANSLUCENT )
			{
				o.flOpacity *= m.Opacity * g_flOpacityScale;
			}
			#endif

			o = CalculateDiffuseAndSpecularFromAlbedoAndMetalness( o, m.Albedo.rgb, m.Metalness );

			PS_CommonTransformNormal( i, o, DecodeHemiOctahedronNormal( m.Normal.rg ) );
			o.vRoughness = m.Roughness;
			o.flRetroReflectivity = 1.0f;
			o.vEmissive = m.Emission;
			o.flAmbientOcclusion = m.AmbientOcclusion.x;
			o.vTransmissiveMask = m.Transmission;

			return o;
		}

		void Init( const PixelInput pixelInput, const Material material )
		{
			Input = MaterialToCombinerInput( pixelInput, material );
			shadeParams = ShadeParams::ProcessMaterial( pixelInput, material );
		}

		float3 DiffuseLobe( const LightData light )
		{
			const float3 h = normalize(shadeParams.inputs.ViewRayWs + light.LightDir);

			const float NoV = shadeParams.inputs.NoV;
			const float NoL = saturate(light.NdotL);
			const float NoH = saturate(dot(shadeParams.inputs.NormalWs, h));
			const float LoH = saturate(dot(light.LightDir, h));

			float3 diffuse = diffuseLobe( shadeParams, NoV, NoL, LoH);
			
			// TODO: attenuate the diffuse lobe to avoid energy gain

			// The energy compensation term is used to counteract the darkening effect
			// at high roughness
			float fEnergyCompensation = 1.0f;

			float3 color = diffuse * fEnergyCompensation;

			return (color * light.Color.rgb) *
					( light.Attenuation * NoL * light.Visibility );
		}
		
		LightShade Direct( const LightData light )
		{
			LightShade o;
			#if S_NON_DIRECTIONAL_DIFFUSE_LIGHTING
				o.Diffuse = 0;
				o.Specular = 0;
			#else
				o.Diffuse = DiffuseLobe(light);
				o.Specular = 0;
			#endif
			return o;
		}
		
		LightShade Indirect()
		{
			LightShade o;
			
			float3 vColor = PS_FinalCombiner( Input ).vColor.rgb;

			o.Diffuse = vColor;
			o.Specular = 0;
			return o;
		}
	};

	float3 hueShift(float3 color, float hue) {
		const float3 k = float3(0.57735, 0.57735, 0.57735);
		float cosAngle = cos(hue);
		return float3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));
	}

	PixelOutput MainPs( PixelInput i )
	{
		float4 vColor = Tex2DLevelS( g_tColor, g_sPointSampler, i.vTextureCoords.xy, 0 );
		Material m = GatherMaterial( i );
		
		bool hasTintColor = (g_vTintColor.r < 1.0f || g_vTintColor.g < 1.0f || g_vTintColor.b < 1.0f );
		
		if ( g_HueShift > 0 || hasTintColor )
		{
			if ( hasTintColor )
				vColor.rgb *= g_vTintColor.rgb;
		
			if ( g_HueShift > 0 )
				vColor.rgb = hueShift( vColor.rgb, (3.14f / 128.0f) * g_HueShift );
		}
		
		float3 vRma = Tex2DLevelS( g_tModelRma, g_sPointSampler, i.vTextureCoords.xy, 0 ).rgb;
		float3 vEmission = Tex2DLevelS( g_tModelEmission, g_sPointSampler, i.vTextureCoords.xy, 0 ).rgb;
		
		float3 torchColor = (g_vVoxelLight.rgb / 16.0f) * (1.0f - (((sin(g_flTime * 8.0f) + 1.0f) * 0.5f) * 0.2f));
		float sunlight = g_vVoxelLight.w / 16.0f;
		sunlight *= sunlight;
		float brightness = 0.8f;
		
		m.TintMask = 1.0f;
		m.Opacity = 1.0f;
		m.Albedo.rgb = vColor.rgb * saturate(0.007f + torchColor + sunlight * brightness);
		m.Normal = Tex2DLevelS( g_tModelNormal, g_sPointSampler, i.vTextureCoords.xy, 0 ).rgb;
		m.Roughness = vRma.r;
		m.Metalness = vRma.g;
		m.AmbientOcclusion = vRma.b;
		m.AmbientOcclusion = vRma.b;
		m.Emission.rgb = m.Albedo.rgb * vEmission;
		
		ShadingModelValveWithDiffuse sm;
		return FinalizePixelMaterial( i, m, sm );
	}
}
