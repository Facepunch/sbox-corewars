//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
	DevShader = true;
	CompileTargets = ( IS_SM_50 && ( PC || VULKAN ) );
	Description = "Voxel";
	DebugInfo = false;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
	#include "common/features.hlsl"
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
MODES
{
	VrForward();
	Depth( S_MODE_DEPTH );
	ToolsVis( S_MODE_TOOLS_VIS );
	ToolsWireframe( S_MODE_TOOLS_WIREFRAME );
	ToolsShadingComplexity( "vr_tools_shading_complexity.vfx" );
}

//=========================================================================================================================
COMMON
{
	#include "system.fxc" // This should always be the first include in COMMON
	#include "sbox_shared.fxc"
	#define VS_INPUT_HAS_TANGENT_BASIS 1
	#define PS_INPUT_HAS_TANGENT_BASIS 1

	float g_flVoxelSize < Default( 32.0 ); >;
}

//=========================================================================================================================

struct VertexInput
{
	#include "common/vertexinput.hlsl"

	uint2 vData : TEXCOORD10 < Semantic( None ); >;
};

//=========================================================================================================================

struct PixelInput
{
	#include "common/pixelinput.hlsl"
	float2 vTexCoord : TEXCOORD9;
	uint nTextureIndex : TEXCOORD10;
	int3 vPositionOs : TEXCOORD11;
};

//=========================================================================================================================

VS
{
	#include "common/vertex.hlsl"
	

	PixelInput MainVs( INSTANCED_SHADER_PARAMS( VertexInput i ) )
	{
		int3 chunkPosition = int3( i.vData.y & 63, (i.vData.y >> 6) & 63, (i.vData.y >> 12) & 63 );

		float3 position = float3( float( i.vData.x & ( 63 ) ), float( ( i.vData.x >> 6 ) & ( 63 ) ), float( ( i.vData.x >> 12 ) & ( 63 ) ) );
		int texindex = int( ( i.vData.x >> 18 ) & ( 31 ) );
		int normal = int( ( i.vData.x >> 27 ) & ( 7 ) );

		i.vPositionOs = position * g_flVoxelSize;

		float3 vNormalOs = float3( 0, 0, 1.0f );
		if ( normal == 1 ) vNormalOs = float3( 0, 0, -1 );
		else if ( normal == 2 ) vNormalOs = float3( 0, -1, 0 );
		else if ( normal == 3 ) vNormalOs = float3( 0, 1, 0 );
		else if ( normal == 4 ) vNormalOs = float3( -1, 0, 0 );
		else if ( normal == 5 ) vNormalOs = float3( 1, 0, 0 );

		float3 vTangentOs = float3( 1, 0, 0 );
		if ( normal == 1 ) vTangentOs = float3( 1, 0, 0 );
		else if ( normal == 2 ) vTangentOs = float3( 0, 0, -1 );
		else if ( normal == 3 ) vTangentOs = float3( 0, 0, -1 );
		else if ( normal == 4 ) vTangentOs = float3( 0, 0, -1 );
		else if ( normal == 5 ) vTangentOs = float3( 0, 0, -1 );

		float3 vBinormalOs = cross( vNormalOs, vTangentOs );
		float2 vTexCoord = float2( dot( vBinormalOs, i.vPositionOs ), dot( vTangentOs, i.vPositionOs ) );
		PixelInput o = ProcessVertex( i );
		o.vNormalWs = vNormalOs;
		o.vTangentUWs = vBinormalOs;
		o.vTangentVWs = vTangentOs;
		o.vTexCoord = vTexCoord.xy;
		o.nTextureIndex = texindex;

		// Fudge the number up a little so we're not checking the current(in ground) blocks
		o.vPositionOs = chunkPosition + vNormalOs;
		return FinalizeVertex( o );
	}
}

//=========================================================================================================================

PS
{
	float flTextureAtlasCellSize< Default(64.0f); >;
	StaticCombo( S_MODE_DEPTH, 0..1, Sys( ALL ) );
	StaticCombo( S_MODE_TOOLS_WIREFRAME, 0..1, Sys( ALL ) );

	#if ( S_MODE_TOOLS_WIREFRAME )
		RenderState( FillMode, WIREFRAME );
		RenderState( SlopeScaleDepthBias, -0.5 );
		RenderState( DepthBiasClamp, -0.0005 );
		RenderState( DepthWriteEnable, false );
		#define DEPTH_STATE_ALREADY_SET
	#endif

	#include "common/pixel.hlsl"

	CreateInputTexture2D( TextureAtlas, Srgb, 8, "", "_color", "Voxel Atlas,10/10", Default3( 1.0f, 1.0f, 1.0f ) );
	CreateTexture2D( g_tAtlasColor )  < Channel( RGB,  None( TextureAtlas ), Srgb ); OutputFormat( BC7 ); SrgbRead( true ); Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); >;

	CreateInputTexture3D( TextureLightmap, Linear, 8, "", "_lightmap", "Voxel Atlas,20/10", Default3( 1.0, 1.0, 1.0 ) );
	
	// Move all this to C#
	CreateInputTexture3D( TextureLightmapWest, Linear, 8, "", "_lightmap", "Voxel Atlas,30/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureLightmapSouth, Linear, 8, "", "_lightmap", "Voxel Atlas,40/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureLightmapEast, Linear, 8, "", "_lightmap", "Voxel Atlas,50/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureLightmapNorth, Linear, 8, "", "_lightmap", "Voxel Atlas,60/10", Default3( 1.0, 1.0, 1.0 ) );

	CreateTexture3DWithoutSampler( g_tLightmap ) < Channel( A, None( TextureLightmap ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( CLAMP ); AddressV( CLAMP ); AddressW( CLAMP ); > ;
	
	// We can't do this because the inputs are dynamic :(
	//CreateTexture3DWithoutSampler( g_tLightmapAdjacent ) < Channel( R, None( TextureLightmapWest ), Linear ); Channel( G, None( TextureLightmapSouth ), Linear ); Channel( B, None( TextureLightmapEast ), Linear ); Channel( A, None( TextureLightmapNorth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); AddressW( MIRROR ); > ;
	CreateTexture3DWithoutSampler( g_tLightmapAdjacent0 ) < Channel( A, None( TextureLightmapWest ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV(WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tLightmapAdjacent1 ) < Channel( A, None( TextureLightmapSouth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV(WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tLightmapAdjacent2 ) < Channel( A, None( TextureLightmapEast ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV(WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tLightmapAdjacent3 ) < Channel( A, None( TextureLightmapNorth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV(WRAP ); AddressW( WRAP ); > ;


	CreateInputTexture3D( TextureSunlight, Linear, 8, "", "_sunlight", "Voxel Atlas,70/10", Default3( 1.0, 1.0, 1.0 ) );

	// Move all this to C#
	CreateInputTexture3D( TextureSunlightWest, Linear, 8, "", "_sunlight", "Voxel Atlas,80/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureSunlightSouth, Linear, 8, "", "_sunlight", "Voxel Atlas,90/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureSunlightEast, Linear, 8, "", "_sunlight", "Voxel Atlas,100/10", Default3( 1.0, 1.0, 1.0 ) );
	CreateInputTexture3D( TextureSunlightNorth, Linear, 8, "", "_sunlight", "Voxel Atlas,110/10", Default3( 1.0, 1.0, 1.0 ) );

	CreateTexture3DWithoutSampler( g_tSunlight ) < Channel( A, None( TextureSunlight ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( CLAMP ); AddressV( CLAMP ); AddressW( CLAMP ); > ;
	CreateTexture3DWithoutSampler( g_tSunlightAdjacent0 ) < Channel( A, None( TextureSunlightWest ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV( WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tSunlightAdjacent1 ) < Channel( A, None( TextureSunlightSouth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV( WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tSunlightAdjacent2 ) < Channel( A, None( TextureSunlightEast ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV( WRAP ); AddressW( WRAP ); > ;
	CreateTexture3DWithoutSampler( g_tSunlightAdjacent3 ) < Channel( A, None( TextureSunlightNorth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( WRAP ); AddressV( WRAP ); AddressW( WRAP ); > ;
	//CreateTexture3DWithoutSampler( g_tSunlightAdjacent ) < Channel( R, None( TextureSunlightWest ), Linear ); Channel( G, None( TextureSunlightSouth ), Linear ); Channel( B, None( TextureSunlightEast ), Linear ); Channel( A, None( TextureSunlightNorth ), Linear ); OutputFormat( RGBA8888 ); SrgbRead( false ); Filter( POINT ); AddressU( MIRROR ); AddressV( MIRROR ); AddressW( MIRROR ); > ;


	PixelOutput MainPs( PixelInput i )
	{
		#if ( S_MODE_DEPTH )
		{
			PixelOutput o;
			o.vColor.rgba = float4( 0.0, 0.0, 0.0, 1.0 );
			return o;
		}
		#elif ( S_MODE_TOOLS_WIREFRAME )
		{
			PixelOutput o;
			o.vColor.rgba = float4( g_vWireframeColor.rgb, 1.0f );
			return o;
		}
		#else
		{
			float2 vAtlasDims = TextureDimensions2D( g_tAtlasColor, 0 ).xy;
			int3 vLightmapDim = TextureDimensions3D( g_tLightmap, 0 );

			float2 vAltasMaxCells = vAtlasDims / flTextureAtlasCellSize;
			float2 vInvMaxCells = 1.0f / vAltasMaxCells;

			float2 vCellLocation =  float2( i.nTextureIndex % vAltasMaxCells.x, floor( i.nTextureIndex / vAltasMaxCells.x ) );

			// Normalized to Atlas Space
			float2 vTexCoordAtlas = frac((i.vTexCoord.xy % g_flVoxelSize) / g_flVoxelSize);
			vTexCoordAtlas = frac((vTexCoordAtlas / vAltasMaxCells) + (vCellLocation * vInvMaxCells));

			float lightmapBrightness = 0.0f;
			float sunlightBrightness = 0.0f;
			if( i.vPositionOs.x < 0 )
			{
				// x - 1
				lightmapBrightness = Tex3DLoad( g_tLightmapAdjacent0, int4( vLightmapDim.x - 1, i.vPositionOs.yz, 0 ) ).a * 16.0f;
				sunlightBrightness = Tex3DLoad( g_tSunlightAdjacent0, int4( vLightmapDim.x - 1, i.vPositionOs.yz, 0 ) ).a * 16.0f;
			}
			else if(i.vPositionOs.y < 0)
			{
				// y - 1
				lightmapBrightness = Tex3DLoad( g_tLightmapAdjacent1, int4( i.vPositionOs.x, vLightmapDim.y - 1, i.vPositionOs.z, 0 ) ).a * 16.0f;
				sunlightBrightness = Tex3DLoad( g_tSunlightAdjacent1, int4( i.vPositionOs.x, vLightmapDim.y - 1, i.vPositionOs.z, 0 ) ).a * 16.0f;
			}
			else if(i.vPositionOs.x >= vLightmapDim.x)
			{
				lightmapBrightness = Tex3DLoad( g_tLightmapAdjacent2, int4( 0, i.vPositionOs.yz, 0 ) ).a * 16.0f;
				sunlightBrightness = Tex3DLoad( g_tSunlightAdjacent2, int4( 0, i.vPositionOs.yz, 0 ) ).a * 16.0f;
			}
			else if(i.vPositionOs.y >= vLightmapDim.y)
			{
				lightmapBrightness = Tex3DLoad( g_tLightmapAdjacent3, int4( i.vPositionOs.x, 0, i.vPositionOs.z, 0 ) ).a * 16.0f;
				sunlightBrightness = Tex3DLoad( g_tSunlightAdjacent3, int4( i.vPositionOs.x, 0, i.vPositionOs.z, 0 ) ).a * 16.0f;
			}
			else
			{
				lightmapBrightness = Tex3DLoad( g_tLightmap, int4( i.vPositionOs.xyz, 0 ) ).a * 16.0f;
				sunlightBrightness = Tex3DLoad( g_tSunlight, int4( i.vPositionOs.xyz, 0 ) ).a * 16.0f;
			}

			Material m = GatherMaterial( i );
			m.Albedo.rgb = Tex2DLevel( g_tAtlasColor, vTexCoordAtlas, 0 ).rgb * saturate(0.03f + (lightmapBrightness + sunlightBrightness));

			return FinalizePixelMaterial( i, m );
		}
		#endif
	}
}